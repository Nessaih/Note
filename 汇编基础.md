### 第一课 十进制、二进制、十六进制

### 第二课 进制转换

### 第三课 计算机工作流程

1. 计算机的硬件：
   中央处理器、存储器、输入输出设备
   CPU：计算机的大脑，控制整个计算机的运行
   硬盘（外部存储器）：容量大、存取慢、断电保存
   内盘（内部存储器）：容量小、存取快、断电丢失

2. 计算机的工作流程：CPU把硬盘中的代码、数据读取到内存中，再去处理。

### 第四课 内存空间

1. 内存空间：
   + 存储单元:8 bit，即 1 byte；
   + 内存编号:从0开始编号。
2. 内存数据：数据即指令，指令即数据。

### 第五课 段地址与偏移地址

1.DEBUG
    + 可以自由的查看内存空间状况
    + D：查看内存中的内容
        + 格式：
        + D 开始地址 : 列出从此地址后的128个存储单元中的内容；
        + D 开始地址 结束地址 : 列出此范围编号内存储单元中内容；
        + Q : 退出。

2. 段地址与偏移地址
   内存存储单元编号 = 起始地址        + 偏移地址；
   内存存储单元编号 = 段地址(末尾补0) + 偏移地址 。

### 第六课 内存空间编辑

1. DEBUG  
   + E：改写内存中的内容；
   + 格式：
   + E 开始地址 数据 数据  ...
   + E 开始地址
   + U：把内存中的数据翻译成汇编指令
   + 格式：
   + U 开始地址         从指定地址开始,反汇编32字节
   + 开始地址 终止地址     对指定范围内的存储单元数据进行反汇编

### 第七课 ASCII码

### 第八课 初识汇编

1. 机器语言:即机器指令，计算机可以识别；
2. 汇编语言:以汇编指令为核心，方便人类记忆，与机器指令对应；
3. 编译器：把汇编指令(汇编语言)转变为机器指令(机器语言)；
4. 汇编语言组成：汇编指令、伪指令。

### 第九课 汇编语言的跟踪

1. DEBUG：可以编写、汇编、跟踪、调试汇编程序；
2. A命令:
   + A 键入汇编语言语句，并能把它们汇编成机器代码；
   + 格式：A 开始地址。
3. U命令：
   + U 把内存中的数据翻译成汇编指令
     格式：U 开始地址 （含义：从指定地址开始，反汇编32个字节）

### 第十课 通用寄存器

1. CPU的结构：运算器、寄存器、控制器；
2. 通用寄存器：
   + 通用寄存器(16位)：AX、BX、CX、DX;
   + 通用寄存器(8位)：AH、AL、BH、BL、CH、CL、DH、DL；
   + 注：AX分为AH、AL，BX、CX、DX相同。

### 第十一课 汇编指令

    （合并第十一至第十三课）

1. 字节与字

   + 字节(byte)：1byte, 8bit
   + 字(word)：2byte, 16bit

2. MOV指令

   + 作用：往某个寄存器中存入数值
   + 格式1： MOV 寄存器名称,数值
   + 格式2： MOV 寄存器名称,寄存器名称
   + 注：（1）汇编指令不区分大小写；（2）两者数值的存储容量位数须匹配。

3. ADD指令

   + 作用：把两个数值相加，将结果放到第一个数值容器里；
   + 格式1： ADD 寄存器名称,数值
   + 格式2： ADD 寄存器名称,寄存器名称
   + 注：（1）汇编指令不区分大小写；（2）两者数值的存储容量位数须匹配。

4. JMP指令

   CS：指向CPU将要执行指令的段地址；
   IP：指向CPU将要执行指令的偏移地址；

   程序执行步骤：
   
   a)  读取CS：IP指向的内存中的指令；
   
   b） IP指向下一条指令的开始偏移地址；
   
   c） 执行指令，回到a步。

   

   + JMP指令
   + 作用：更改CS:IP寄存器的内容，以让CPU从新指定的内存地址开始继续执行指令。
   + 格式： JMP 段地址:偏移地址

### 第十四课 代码段

1. 内存中程序分布的规划：自由；
2. 代码段：在内存中存放代码的连续内存单元.

### 第十五课 数据段

1. 内存数据的存储:
   byte型：一个内存单元的数据；
   word型：连续两个内存单元的数据；遵循高地址是高位，低地址是低位。
2. 数据段：在内存中存放数据的连续内存单元。

### 第十六课 内存、寄存器数据传送

    DS       ：内存单元的段地址；
    [偏移地址]：内存单元的偏移地址；

1. 从内存中取数据存放到寄存器中

   格式：
   MOV 寄存器,[偏移地址]

2. 从寄存器中取数据存放到内存中

   格式：
   MOV [偏移地址]，寄存器

### 第十七课 MOV、ADD指令小节

1. MOV指令
   + MOV 寄存器,数据
   + MOV 寄存器,寄存器
   + MOV 寄存器,段寄存器
   + MOV 寄存器,[偏移地址]
   + MOV [偏移地址]，寄存器

2. ADD指令
   + ADD 寄存器,数据
   + ADD 寄存器,寄存器
   + ADD 寄存器,[偏移地址]
   + ADD [偏移地址]，寄存器

第十八课 栈

1. 栈的原理：内存中使用一段连续内存单元，看做成只有一个上口的盒子，用于存放数据。
1. 栈的操作：
   + 入栈：向盒子里放数据；
   + 出栈：从盒子里拿数据；
   + 单位：以字为单位；
   + 规则：先进后出。

### 第十九课 栈的操作

1. 栈指令
   + 入栈： push 通用寄存器
   + 出栈： pop  通用寄存器

2. 栈顶单元地址
   栈段地址：栈偏移地址  栈顶地址
   SS:SP               栈顶地址

### 第二十课 push、pop指令

1. push 指令
   + push 寄存器
   + push 段寄存器
   + push [偏移地址]

2. pop 指令
   + pop 寄存器
   + pop 段寄存器
   + pop [偏移地址]

### 第二十一课 栈空间

1. 栈空间范围
   + SS:SP    栈顶地址
   + SP范围： 0~FFFFH

2. 栈顶地址环绕
   + CLI 中断标记(IF)置零
   + 当栈满时，再次入栈操作将使SP环绕
   + 当栈空时，再次出栈操作将使SP环绕

3. 栈覆盖：当栈段与数据段、代码段相同时，小心栈覆盖

### 第二十二课 段总结

1.段分类 
    + 数据段：存放数据
    + 代码段：存放代码
    + 栈  段：此段存放栈内容
    + 注：我们可以把内存中某段内存空间安排成某种段。

2. CPU的段识别
   + 数据段： 设置DS寄存器存放此段段地址，偏移地址由"[偏移地址]"给出。
   + 代码段： 设置CS寄存器存放此段段地址，偏移地址由IP寄存器存放。
   + 栈  段： 设置SS寄存器存放此段段地址，偏移地址由SP寄存存放。

3. 段混用：同一段内存空间，我们可以同时指定为数据段、代码段、栈段。

### 第二十三课 汇编语言的编译

1. Debug：可以编写、汇编、跟踪、调试汇编程序；

2. Masm

   + 编译器：将汇编语言源代码文件生成含有机器代码指令的目标程序文件。
   + 汇编程序：

   ```assembly
   assume CS:daima
     
   daima segment
       mov ax,1234H
       mov ax,4C00H
       int 21H
   daima ends
     
   end
   ```

### 第二十四课 伪指令

1. 伪指令
   + 由编译器来执行的指令，编译器根据伪指令进行编译工作。
   + 最终生成的目标文件里不包含源代码中的伪指令。

### 第二十五课 程序返回、数值类型表示、代码注释

1. 程序返回

  + 功能：程序返回，结束执行。
  + 语法:

   ```assembly
	mov ax,4C00H
	int 21H
   ```


2. 数值类型表示
   + 二进制：B
   + 十进制：D
   + 十六进制：H

3. 汇编代码中的注释：
   + 功能：对源代码起到说明作用，方便代码阅读管理。
   + 语法1：`; 注释类容 `
   + 语法2：`汇编语句 ; 注释类容`

### 第二十六课 直接、寄存器间接寻址

1. 直接寻址：偏移地址直接出现在执行代码中。

   ```assembly
   mov 寄存器,[偏移地址]
   mov [偏移地址],寄存器
   ```

2. 寄存器间接寻址：偏移地址通过寄存器取得使用。

   ```assembly
   mov 寄存器,[寄存器]
   mov [寄存器],寄存器
   ```

### 第二十七课 加减算法指令

1. 加法指令

+ ADD：加法
  * 语法：ADD 目的操作数,源操作数
  * 执行的操作：目的操作数 <- 目的操作数 + 源操作数
+ INC：加一
  * 语法：INC 操作数
  * 执行的操作：操作数 <- 操作数 + 1

2. 减法指令

+ SUB：减法
  * 语法：SUB 目的操作数,源操作数
  * 执行的操作：目的操作数 <- 目的操作数 - 源操作数
+ DEC：减一
  * 语法：INC 操作数
  * 执行的操作：操作数 <- 操作数 - 1

### 第二十八课 Loop循环指令

1.Loop循环指令

+ 语法：loop 标号
+ 执行步骤：
  * 将cx寄存器中的值减1
  * 判断cx寄存器中的值是否为0，不为0转置标号处执行程序，为0向下执行
+ 标号：在汇编程序中，为指令的位置做标记。
+ 模型：

```assembly
mov cx,循环次数
标号:
    循环体
loop 标号
```

### 第二十九课 段前缀

1. 段前缀：使用段寄存器前缀的形式显式的给出内存单元的段地址。

+ 格式：段寄存器:[偏移地址]

### 第三十课 定义数据

1. 定义数据
   (1)伪操作用来定义字节数据，其后的每个操作数都占有一个字节(8位)
   `db 数据,数据,...数据,`
   (2)伪操作用来定义字数据，其后的每个操作数都占有一个字(16位)
   `dw 数据,数据,...数据,`
2. 编译结束伪指令

+ 功能：告诉编译器，编译到此为止，并且指定计算机从何处开始执行程序。
+ 语法：end 标号

### 第三十一课 定义栈

1. 定义栈

   ```assembly
   ;伪操作用来定义字数据，其后的每个操作数都占有一个字(16位)
   dw 数据,数据,...数据,
   ```

+ dw 伪指令用来将其后的数据存入指定的存储单元中;
+ 使用dw伪指令可以变相的开辟内存空间，以用作栈使用。

